Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    and
    newline
    or
    while

Grammar

Rule 0     S' -> program
Rule 1     program -> dekl_list
Rule 2     dekl_list -> dekl
Rule 3     dekl_list -> expression
Rule 4     dekl_list -> dekl dekl_list
Rule 5     dekl_list -> block
Rule 6     dekl -> var var_dekl
Rule 7     dekl -> let var_dekl
Rule 8     dekl -> fun_dekl
Rule 9     var_dekl -> id ddot dtype semicolon
Rule 10    var_dekl -> id ddot dtype equals expression semicolon
Rule 11    dtype -> int
Rule 12    dtype -> bool
Rule 13    expression -> expression minus term
Rule 14    expression -> expression plus term
Rule 15    expression -> term
Rule 16    term -> term multiply factor
Rule 17    term -> term divide factor
Rule 18    term -> factor
Rule 19    factor -> lparent expression rparent
Rule 20    factor -> minus expression
Rule 21    factor -> val
Rule 22    factor -> call
Rule 23    empty -> <empty>
Rule 24    call -> id lparent arguments rparent semicolon
Rule 25    call -> id lparent rparent semicolon
Rule 26    val -> int
Rule 27    val -> id
Rule 28    fun_dekl -> func id lparent params rparent arrow dtype comp_block
Rule 29    params -> params_var
Rule 30    params -> empty
Rule 31    params_var -> id ddot dtype comma params_var
Rule 32    params_var -> id ddot dtype
Rule 33    arguments -> val comma arguments
Rule 34    arguments -> val
Rule 35    comp_block -> lcparent block rcparent
Rule 36    block -> comp_block block
Rule 37    block -> loop_block block
Rule 38    block -> cond_block block
Rule 39    block -> ass_exp semicolon block
Rule 40    block -> dekl block
Rule 41    block -> return expression semicolon
Rule 42    loop_block -> for lparent loop_var condition semicolon step semicolon rparent
Rule 43    cond_block -> if lparent condition rparent comp_block
Rule 44    cond_block -> if lparent condition rparent comp_block else comp_block
Rule 45    loop_var -> var_dekl
Rule 46    loop_var -> id
Rule 47    step -> id add int
Rule 48    step -> id sub int
Rule 49    condition -> expression relation_operator expression
Rule 50    ass_exp -> var id ddot dtype equals expression
Rule 51    ass_exp -> let id ddot dtype equals expression
Rule 52    ass_exp -> id equals expression
Rule 53    relation_operator -> equals_equals
Rule 54    relation_operator -> lt
Rule 55    relation_operator -> gt
Rule 56    relation_operator -> le
Rule 57    relation_operator -> ge
Rule 58    relation_operator -> not_equal

Terminals, with rules where they appear

add                  : 47
and                  : 
arrow                : 28
bool                 : 12
comma                : 31 33
ddot                 : 9 10 31 32 50 51
divide               : 17
else                 : 44
equals               : 10 50 51 52
equals_equals        : 53
error                : 
for                  : 42
func                 : 28
ge                   : 57
gt                   : 55
id                   : 9 10 24 25 27 28 31 32 46 47 48 50 51 52
if                   : 43 44
int                  : 11 26 47 48
lcparent             : 35
le                   : 56
let                  : 7 51
lparent              : 19 24 25 28 42 43 44
lt                   : 54
minus                : 13 20
multiply             : 16
newline              : 
not_equal            : 58
or                   : 
plus                 : 14
rcparent             : 35
return               : 41
rparent              : 19 24 25 28 42 43 44
semicolon            : 9 10 24 25 39 41 42 42
sub                  : 48
var                  : 6 50
while                : 

Nonterminals, with rules where they appear

arguments            : 24 33
ass_exp              : 39
block                : 5 35 36 37 38 39 40
call                 : 22
comp_block           : 28 36 43 44 44
cond_block           : 38
condition            : 42 43 44
dekl                 : 2 4 40
dekl_list            : 1 4
dtype                : 9 10 28 31 32 50 51
empty                : 30
expression           : 3 10 13 14 19 20 41 49 49 50 51 52
factor               : 16 17 18
fun_dekl             : 8
loop_block           : 37
loop_var             : 42
params               : 28
params_var           : 29 31
program              : 0
relation_operator    : 49
step                 : 42
term                 : 13 14 15 16 17
val                  : 21 33 34
var_dekl             : 6 7 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . dekl_list
    (2) dekl_list -> . dekl
    (3) dekl_list -> . expression
    (4) dekl_list -> . dekl dekl_list
    (5) dekl_list -> . block
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    var             shift and go to state 6
    let             shift and go to state 7
    return          shift and go to state 15
    func            shift and go to state 16
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    id              shift and go to state 17
    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25

    program                        shift and go to state 1
    dekl_list                      shift and go to state 2
    dekl                           shift and go to state 3
    expression                     shift and go to state 4
    block                          shift and go to state 5
    fun_dekl                       shift and go to state 8
    term                           shift and go to state 10
    comp_block                     shift and go to state 11
    loop_block                     shift and go to state 12
    cond_block                     shift and go to state 13
    ass_exp                        shift and go to state 14
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 1

    (0) S' -> program .



state 2

    (1) program -> dekl_list .

    $end            reduce using rule 1 (program -> dekl_list .)


state 3

    (2) dekl_list -> dekl .
    (4) dekl_list -> dekl . dekl_list
    (40) block -> dekl . block
    (2) dekl_list -> . dekl
    (3) dekl_list -> . expression
    (4) dekl_list -> . dekl dekl_list
    (5) dekl_list -> . block
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    $end            reduce using rule 2 (dekl_list -> dekl .)
    return          shift and go to state 15
    var             shift and go to state 6
    let             shift and go to state 7
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    id              shift and go to state 17
    func            shift and go to state 16
    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25

    dekl                           shift and go to state 3
    dekl_list                      shift and go to state 26
    block                          shift and go to state 27
    expression                     shift and go to state 4
    comp_block                     shift and go to state 11
    loop_block                     shift and go to state 12
    cond_block                     shift and go to state 13
    ass_exp                        shift and go to state 14
    fun_dekl                       shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 4

    (3) dekl_list -> expression .
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    $end            reduce using rule 3 (dekl_list -> expression .)
    minus           shift and go to state 28
    plus            shift and go to state 29


state 5

    (5) dekl_list -> block .

    $end            reduce using rule 5 (dekl_list -> block .)


state 6

    (6) dekl -> var . var_dekl
    (50) ass_exp -> var . id ddot dtype equals expression
    (9) var_dekl -> . id ddot dtype semicolon
    (10) var_dekl -> . id ddot dtype equals expression semicolon

    id              shift and go to state 31

    var_dekl                       shift and go to state 30

state 7

    (7) dekl -> let . var_dekl
    (51) ass_exp -> let . id ddot dtype equals expression
    (9) var_dekl -> . id ddot dtype semicolon
    (10) var_dekl -> . id ddot dtype equals expression semicolon

    id              shift and go to state 33

    var_dekl                       shift and go to state 32

state 8

    (8) dekl -> fun_dekl .

    return          reduce using rule 8 (dekl -> fun_dekl .)
    var             reduce using rule 8 (dekl -> fun_dekl .)
    let             reduce using rule 8 (dekl -> fun_dekl .)
    lcparent        reduce using rule 8 (dekl -> fun_dekl .)
    for             reduce using rule 8 (dekl -> fun_dekl .)
    if              reduce using rule 8 (dekl -> fun_dekl .)
    id              reduce using rule 8 (dekl -> fun_dekl .)
    func            reduce using rule 8 (dekl -> fun_dekl .)
    lparent         reduce using rule 8 (dekl -> fun_dekl .)
    minus           reduce using rule 8 (dekl -> fun_dekl .)
    int             reduce using rule 8 (dekl -> fun_dekl .)
    $end            reduce using rule 8 (dekl -> fun_dekl .)


state 9

    (20) factor -> minus . expression
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 34
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 10

    (15) expression -> term .
    (16) term -> term . multiply factor
    (17) term -> term . divide factor

  ! shift/reduce conflict for multiply resolved as shift
  ! shift/reduce conflict for divide resolved as shift
    minus           reduce using rule 15 (expression -> term .)
    plus            reduce using rule 15 (expression -> term .)
    $end            reduce using rule 15 (expression -> term .)
    semicolon       reduce using rule 15 (expression -> term .)
    rparent         reduce using rule 15 (expression -> term .)
    equals_equals   reduce using rule 15 (expression -> term .)
    lt              reduce using rule 15 (expression -> term .)
    gt              reduce using rule 15 (expression -> term .)
    le              reduce using rule 15 (expression -> term .)
    ge              reduce using rule 15 (expression -> term .)
    not_equal       reduce using rule 15 (expression -> term .)
    multiply        shift and go to state 36
    divide          shift and go to state 37

  ! multiply        [ reduce using rule 15 (expression -> term .) ]
  ! divide          [ reduce using rule 15 (expression -> term .) ]


state 11

    (36) block -> comp_block . block
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block

    return          shift and go to state 15
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    var             shift and go to state 40
    let             shift and go to state 42
    id              shift and go to state 41
    func            shift and go to state 16

    comp_block                     shift and go to state 11
    block                          shift and go to state 38
    loop_block                     shift and go to state 12
    cond_block                     shift and go to state 13
    ass_exp                        shift and go to state 14
    dekl                           shift and go to state 39
    fun_dekl                       shift and go to state 8

state 12

    (37) block -> loop_block . block
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block

    return          shift and go to state 15
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    var             shift and go to state 40
    let             shift and go to state 42
    id              shift and go to state 41
    func            shift and go to state 16

    loop_block                     shift and go to state 12
    block                          shift and go to state 43
    comp_block                     shift and go to state 11
    cond_block                     shift and go to state 13
    ass_exp                        shift and go to state 14
    dekl                           shift and go to state 39
    fun_dekl                       shift and go to state 8

state 13

    (38) block -> cond_block . block
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block

    return          shift and go to state 15
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    var             shift and go to state 40
    let             shift and go to state 42
    id              shift and go to state 41
    func            shift and go to state 16

    cond_block                     shift and go to state 13
    block                          shift and go to state 44
    comp_block                     shift and go to state 11
    loop_block                     shift and go to state 12
    ass_exp                        shift and go to state 14
    dekl                           shift and go to state 39
    fun_dekl                       shift and go to state 8

state 14

    (39) block -> ass_exp . semicolon block

    semicolon       shift and go to state 45


state 15

    (41) block -> return . expression semicolon
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 46
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 16

    (28) fun_dekl -> func . id lparent params rparent arrow dtype comp_block

    id              shift and go to state 47


state 17

    (52) ass_exp -> id . equals expression
    (27) val -> id .
    (24) call -> id . lparent arguments rparent semicolon
    (25) call -> id . lparent rparent semicolon

    equals          shift and go to state 48
    multiply        reduce using rule 27 (val -> id .)
    divide          reduce using rule 27 (val -> id .)
    minus           reduce using rule 27 (val -> id .)
    plus            reduce using rule 27 (val -> id .)
    $end            reduce using rule 27 (val -> id .)
    lparent         shift and go to state 49


state 18

    (19) factor -> lparent . expression rparent
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 50
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 19

    (18) term -> factor .

    multiply        reduce using rule 18 (term -> factor .)
    divide          reduce using rule 18 (term -> factor .)
    minus           reduce using rule 18 (term -> factor .)
    plus            reduce using rule 18 (term -> factor .)
    $end            reduce using rule 18 (term -> factor .)
    semicolon       reduce using rule 18 (term -> factor .)
    rparent         reduce using rule 18 (term -> factor .)
    equals_equals   reduce using rule 18 (term -> factor .)
    lt              reduce using rule 18 (term -> factor .)
    gt              reduce using rule 18 (term -> factor .)
    le              reduce using rule 18 (term -> factor .)
    ge              reduce using rule 18 (term -> factor .)
    not_equal       reduce using rule 18 (term -> factor .)


state 20

    (35) comp_block -> lcparent . block rcparent
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block

    return          shift and go to state 15
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    var             shift and go to state 40
    let             shift and go to state 42
    id              shift and go to state 41
    func            shift and go to state 16

    block                          shift and go to state 51
    comp_block                     shift and go to state 11
    loop_block                     shift and go to state 12
    cond_block                     shift and go to state 13
    ass_exp                        shift and go to state 14
    dekl                           shift and go to state 39
    fun_dekl                       shift and go to state 8

state 21

    (42) loop_block -> for . lparent loop_var condition semicolon step semicolon rparent

    lparent         shift and go to state 52


state 22

    (43) cond_block -> if . lparent condition rparent comp_block
    (44) cond_block -> if . lparent condition rparent comp_block else comp_block

    lparent         shift and go to state 53


state 23

    (21) factor -> val .

    multiply        reduce using rule 21 (factor -> val .)
    divide          reduce using rule 21 (factor -> val .)
    minus           reduce using rule 21 (factor -> val .)
    plus            reduce using rule 21 (factor -> val .)
    $end            reduce using rule 21 (factor -> val .)
    semicolon       reduce using rule 21 (factor -> val .)
    rparent         reduce using rule 21 (factor -> val .)
    equals_equals   reduce using rule 21 (factor -> val .)
    lt              reduce using rule 21 (factor -> val .)
    gt              reduce using rule 21 (factor -> val .)
    le              reduce using rule 21 (factor -> val .)
    ge              reduce using rule 21 (factor -> val .)
    not_equal       reduce using rule 21 (factor -> val .)


state 24

    (22) factor -> call .

    multiply        reduce using rule 22 (factor -> call .)
    divide          reduce using rule 22 (factor -> call .)
    minus           reduce using rule 22 (factor -> call .)
    plus            reduce using rule 22 (factor -> call .)
    $end            reduce using rule 22 (factor -> call .)
    semicolon       reduce using rule 22 (factor -> call .)
    rparent         reduce using rule 22 (factor -> call .)
    equals_equals   reduce using rule 22 (factor -> call .)
    lt              reduce using rule 22 (factor -> call .)
    gt              reduce using rule 22 (factor -> call .)
    le              reduce using rule 22 (factor -> call .)
    ge              reduce using rule 22 (factor -> call .)
    not_equal       reduce using rule 22 (factor -> call .)


state 25

    (26) val -> int .

    multiply        reduce using rule 26 (val -> int .)
    divide          reduce using rule 26 (val -> int .)
    minus           reduce using rule 26 (val -> int .)
    plus            reduce using rule 26 (val -> int .)
    $end            reduce using rule 26 (val -> int .)
    semicolon       reduce using rule 26 (val -> int .)
    rparent         reduce using rule 26 (val -> int .)
    equals_equals   reduce using rule 26 (val -> int .)
    lt              reduce using rule 26 (val -> int .)
    gt              reduce using rule 26 (val -> int .)
    le              reduce using rule 26 (val -> int .)
    ge              reduce using rule 26 (val -> int .)
    not_equal       reduce using rule 26 (val -> int .)
    comma           reduce using rule 26 (val -> int .)


state 26

    (4) dekl_list -> dekl dekl_list .

    $end            reduce using rule 4 (dekl_list -> dekl dekl_list .)


state 27

    (40) block -> dekl block .
    (5) dekl_list -> block .

  ! reduce/reduce conflict for $end resolved using rule 5 (dekl_list -> block .)
    $end            reduce using rule 5 (dekl_list -> block .)

  ! $end            [ reduce using rule 40 (block -> dekl block .) ]


state 28

    (13) expression -> expression minus . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    term                           shift and go to state 54
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 29

    (14) expression -> expression plus . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    term                           shift and go to state 55
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 30

    (6) dekl -> var var_dekl .

    return          reduce using rule 6 (dekl -> var var_dekl .)
    var             reduce using rule 6 (dekl -> var var_dekl .)
    let             reduce using rule 6 (dekl -> var var_dekl .)
    lcparent        reduce using rule 6 (dekl -> var var_dekl .)
    for             reduce using rule 6 (dekl -> var var_dekl .)
    if              reduce using rule 6 (dekl -> var var_dekl .)
    id              reduce using rule 6 (dekl -> var var_dekl .)
    func            reduce using rule 6 (dekl -> var var_dekl .)
    lparent         reduce using rule 6 (dekl -> var var_dekl .)
    minus           reduce using rule 6 (dekl -> var var_dekl .)
    int             reduce using rule 6 (dekl -> var var_dekl .)
    $end            reduce using rule 6 (dekl -> var var_dekl .)


state 31

    (50) ass_exp -> var id . ddot dtype equals expression
    (9) var_dekl -> id . ddot dtype semicolon
    (10) var_dekl -> id . ddot dtype equals expression semicolon

    ddot            shift and go to state 56


state 32

    (7) dekl -> let var_dekl .

    return          reduce using rule 7 (dekl -> let var_dekl .)
    var             reduce using rule 7 (dekl -> let var_dekl .)
    let             reduce using rule 7 (dekl -> let var_dekl .)
    lcparent        reduce using rule 7 (dekl -> let var_dekl .)
    for             reduce using rule 7 (dekl -> let var_dekl .)
    if              reduce using rule 7 (dekl -> let var_dekl .)
    id              reduce using rule 7 (dekl -> let var_dekl .)
    func            reduce using rule 7 (dekl -> let var_dekl .)
    lparent         reduce using rule 7 (dekl -> let var_dekl .)
    minus           reduce using rule 7 (dekl -> let var_dekl .)
    int             reduce using rule 7 (dekl -> let var_dekl .)
    $end            reduce using rule 7 (dekl -> let var_dekl .)


state 33

    (51) ass_exp -> let id . ddot dtype equals expression
    (9) var_dekl -> id . ddot dtype semicolon
    (10) var_dekl -> id . ddot dtype equals expression semicolon

    ddot            shift and go to state 57


state 34

    (20) factor -> minus expression .
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    multiply        reduce using rule 20 (factor -> minus expression .)
    divide          reduce using rule 20 (factor -> minus expression .)
    minus           reduce using rule 20 (factor -> minus expression .)
    plus            reduce using rule 20 (factor -> minus expression .)
    $end            reduce using rule 20 (factor -> minus expression .)
    semicolon       reduce using rule 20 (factor -> minus expression .)
    rparent         reduce using rule 20 (factor -> minus expression .)
    equals_equals   reduce using rule 20 (factor -> minus expression .)
    lt              reduce using rule 20 (factor -> minus expression .)
    gt              reduce using rule 20 (factor -> minus expression .)
    le              reduce using rule 20 (factor -> minus expression .)
    ge              reduce using rule 20 (factor -> minus expression .)
    not_equal       reduce using rule 20 (factor -> minus expression .)

  ! minus           [ shift and go to state 28 ]
  ! plus            [ shift and go to state 29 ]


state 35

    (27) val -> id .
    (24) call -> id . lparent arguments rparent semicolon
    (25) call -> id . lparent rparent semicolon

    minus           reduce using rule 27 (val -> id .)
    plus            reduce using rule 27 (val -> id .)
    multiply        reduce using rule 27 (val -> id .)
    divide          reduce using rule 27 (val -> id .)
    $end            reduce using rule 27 (val -> id .)
    semicolon       reduce using rule 27 (val -> id .)
    rparent         reduce using rule 27 (val -> id .)
    equals_equals   reduce using rule 27 (val -> id .)
    lt              reduce using rule 27 (val -> id .)
    gt              reduce using rule 27 (val -> id .)
    le              reduce using rule 27 (val -> id .)
    ge              reduce using rule 27 (val -> id .)
    not_equal       reduce using rule 27 (val -> id .)
    lparent         shift and go to state 49


state 36

    (16) term -> term multiply . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    factor                         shift and go to state 58
    val                            shift and go to state 23
    call                           shift and go to state 24

state 37

    (17) term -> term divide . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    factor                         shift and go to state 59
    val                            shift and go to state 23
    call                           shift and go to state 24

state 38

    (36) block -> comp_block block .

    $end            reduce using rule 36 (block -> comp_block block .)
    rcparent        reduce using rule 36 (block -> comp_block block .)


state 39

    (40) block -> dekl . block
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block

    return          shift and go to state 15
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    var             shift and go to state 40
    let             shift and go to state 42
    id              shift and go to state 41
    func            shift and go to state 16

    dekl                           shift and go to state 39
    block                          shift and go to state 60
    comp_block                     shift and go to state 11
    loop_block                     shift and go to state 12
    cond_block                     shift and go to state 13
    ass_exp                        shift and go to state 14
    fun_dekl                       shift and go to state 8

state 40

    (50) ass_exp -> var . id ddot dtype equals expression
    (6) dekl -> var . var_dekl
    (9) var_dekl -> . id ddot dtype semicolon
    (10) var_dekl -> . id ddot dtype equals expression semicolon

    id              shift and go to state 31

    var_dekl                       shift and go to state 30

state 41

    (52) ass_exp -> id . equals expression

    equals          shift and go to state 48


state 42

    (51) ass_exp -> let . id ddot dtype equals expression
    (7) dekl -> let . var_dekl
    (9) var_dekl -> . id ddot dtype semicolon
    (10) var_dekl -> . id ddot dtype equals expression semicolon

    id              shift and go to state 33

    var_dekl                       shift and go to state 32

state 43

    (37) block -> loop_block block .

    $end            reduce using rule 37 (block -> loop_block block .)
    rcparent        reduce using rule 37 (block -> loop_block block .)


state 44

    (38) block -> cond_block block .

    $end            reduce using rule 38 (block -> cond_block block .)
    rcparent        reduce using rule 38 (block -> cond_block block .)


state 45

    (39) block -> ass_exp semicolon . block
    (36) block -> . comp_block block
    (37) block -> . loop_block block
    (38) block -> . cond_block block
    (39) block -> . ass_exp semicolon block
    (40) block -> . dekl block
    (41) block -> . return expression semicolon
    (35) comp_block -> . lcparent block rcparent
    (42) loop_block -> . for lparent loop_var condition semicolon step semicolon rparent
    (43) cond_block -> . if lparent condition rparent comp_block
    (44) cond_block -> . if lparent condition rparent comp_block else comp_block
    (50) ass_exp -> . var id ddot dtype equals expression
    (51) ass_exp -> . let id ddot dtype equals expression
    (52) ass_exp -> . id equals expression
    (6) dekl -> . var var_dekl
    (7) dekl -> . let var_dekl
    (8) dekl -> . fun_dekl
    (28) fun_dekl -> . func id lparent params rparent arrow dtype comp_block

    return          shift and go to state 15
    lcparent        shift and go to state 20
    for             shift and go to state 21
    if              shift and go to state 22
    var             shift and go to state 40
    let             shift and go to state 42
    id              shift and go to state 41
    func            shift and go to state 16

    ass_exp                        shift and go to state 14
    block                          shift and go to state 61
    comp_block                     shift and go to state 11
    loop_block                     shift and go to state 12
    cond_block                     shift and go to state 13
    dekl                           shift and go to state 39
    fun_dekl                       shift and go to state 8

state 46

    (41) block -> return expression . semicolon
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    semicolon       shift and go to state 62
    minus           shift and go to state 28
    plus            shift and go to state 29


state 47

    (28) fun_dekl -> func id . lparent params rparent arrow dtype comp_block

    lparent         shift and go to state 63


state 48

    (52) ass_exp -> id equals . expression
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 64
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 49

    (24) call -> id lparent . arguments rparent semicolon
    (25) call -> id lparent . rparent semicolon
    (33) arguments -> . val comma arguments
    (34) arguments -> . val
    (26) val -> . int
    (27) val -> . id

    rparent         shift and go to state 67
    int             shift and go to state 25
    id              shift and go to state 65

    arguments                      shift and go to state 66
    val                            shift and go to state 68

state 50

    (19) factor -> lparent expression . rparent
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    rparent         shift and go to state 69
    minus           shift and go to state 28
    plus            shift and go to state 29


state 51

    (35) comp_block -> lcparent block . rcparent

    rcparent        shift and go to state 70


state 52

    (42) loop_block -> for lparent . loop_var condition semicolon step semicolon rparent
    (45) loop_var -> . var_dekl
    (46) loop_var -> . id
    (9) var_dekl -> . id ddot dtype semicolon
    (10) var_dekl -> . id ddot dtype equals expression semicolon

    id              shift and go to state 73

    loop_var                       shift and go to state 71
    var_dekl                       shift and go to state 72

state 53

    (43) cond_block -> if lparent . condition rparent comp_block
    (44) cond_block -> if lparent . condition rparent comp_block else comp_block
    (49) condition -> . expression relation_operator expression
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    condition                      shift and go to state 74
    expression                     shift and go to state 75
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 54

    (13) expression -> expression minus term .
    (16) term -> term . multiply factor
    (17) term -> term . divide factor

    minus           reduce using rule 13 (expression -> expression minus term .)
    plus            reduce using rule 13 (expression -> expression minus term .)
    $end            reduce using rule 13 (expression -> expression minus term .)
    semicolon       reduce using rule 13 (expression -> expression minus term .)
    rparent         reduce using rule 13 (expression -> expression minus term .)
    equals_equals   reduce using rule 13 (expression -> expression minus term .)
    lt              reduce using rule 13 (expression -> expression minus term .)
    gt              reduce using rule 13 (expression -> expression minus term .)
    le              reduce using rule 13 (expression -> expression minus term .)
    ge              reduce using rule 13 (expression -> expression minus term .)
    not_equal       reduce using rule 13 (expression -> expression minus term .)
    multiply        shift and go to state 36
    divide          shift and go to state 37

  ! multiply        [ reduce using rule 13 (expression -> expression minus term .) ]
  ! divide          [ reduce using rule 13 (expression -> expression minus term .) ]


state 55

    (14) expression -> expression plus term .
    (16) term -> term . multiply factor
    (17) term -> term . divide factor

    minus           reduce using rule 14 (expression -> expression plus term .)
    plus            reduce using rule 14 (expression -> expression plus term .)
    $end            reduce using rule 14 (expression -> expression plus term .)
    semicolon       reduce using rule 14 (expression -> expression plus term .)
    rparent         reduce using rule 14 (expression -> expression plus term .)
    equals_equals   reduce using rule 14 (expression -> expression plus term .)
    lt              reduce using rule 14 (expression -> expression plus term .)
    gt              reduce using rule 14 (expression -> expression plus term .)
    le              reduce using rule 14 (expression -> expression plus term .)
    ge              reduce using rule 14 (expression -> expression plus term .)
    not_equal       reduce using rule 14 (expression -> expression plus term .)
    multiply        shift and go to state 36
    divide          shift and go to state 37

  ! multiply        [ reduce using rule 14 (expression -> expression plus term .) ]
  ! divide          [ reduce using rule 14 (expression -> expression plus term .) ]


state 56

    (50) ass_exp -> var id ddot . dtype equals expression
    (9) var_dekl -> id ddot . dtype semicolon
    (10) var_dekl -> id ddot . dtype equals expression semicolon
    (11) dtype -> . int
    (12) dtype -> . bool

    int             shift and go to state 77
    bool            shift and go to state 78

    dtype                          shift and go to state 76

state 57

    (51) ass_exp -> let id ddot . dtype equals expression
    (9) var_dekl -> id ddot . dtype semicolon
    (10) var_dekl -> id ddot . dtype equals expression semicolon
    (11) dtype -> . int
    (12) dtype -> . bool

    int             shift and go to state 77
    bool            shift and go to state 78

    dtype                          shift and go to state 79

state 58

    (16) term -> term multiply factor .

    multiply        reduce using rule 16 (term -> term multiply factor .)
    divide          reduce using rule 16 (term -> term multiply factor .)
    minus           reduce using rule 16 (term -> term multiply factor .)
    plus            reduce using rule 16 (term -> term multiply factor .)
    $end            reduce using rule 16 (term -> term multiply factor .)
    semicolon       reduce using rule 16 (term -> term multiply factor .)
    rparent         reduce using rule 16 (term -> term multiply factor .)
    equals_equals   reduce using rule 16 (term -> term multiply factor .)
    lt              reduce using rule 16 (term -> term multiply factor .)
    gt              reduce using rule 16 (term -> term multiply factor .)
    le              reduce using rule 16 (term -> term multiply factor .)
    ge              reduce using rule 16 (term -> term multiply factor .)
    not_equal       reduce using rule 16 (term -> term multiply factor .)


state 59

    (17) term -> term divide factor .

    multiply        reduce using rule 17 (term -> term divide factor .)
    divide          reduce using rule 17 (term -> term divide factor .)
    minus           reduce using rule 17 (term -> term divide factor .)
    plus            reduce using rule 17 (term -> term divide factor .)
    $end            reduce using rule 17 (term -> term divide factor .)
    semicolon       reduce using rule 17 (term -> term divide factor .)
    rparent         reduce using rule 17 (term -> term divide factor .)
    equals_equals   reduce using rule 17 (term -> term divide factor .)
    lt              reduce using rule 17 (term -> term divide factor .)
    gt              reduce using rule 17 (term -> term divide factor .)
    le              reduce using rule 17 (term -> term divide factor .)
    ge              reduce using rule 17 (term -> term divide factor .)
    not_equal       reduce using rule 17 (term -> term divide factor .)


state 60

    (40) block -> dekl block .

    $end            reduce using rule 40 (block -> dekl block .)
    rcparent        reduce using rule 40 (block -> dekl block .)


state 61

    (39) block -> ass_exp semicolon block .

    $end            reduce using rule 39 (block -> ass_exp semicolon block .)
    rcparent        reduce using rule 39 (block -> ass_exp semicolon block .)


state 62

    (41) block -> return expression semicolon .

    $end            reduce using rule 41 (block -> return expression semicolon .)
    rcparent        reduce using rule 41 (block -> return expression semicolon .)


state 63

    (28) fun_dekl -> func id lparent . params rparent arrow dtype comp_block
    (29) params -> . params_var
    (30) params -> . empty
    (31) params_var -> . id ddot dtype comma params_var
    (32) params_var -> . id ddot dtype
    (23) empty -> .

    id              shift and go to state 80
    rparent         reduce using rule 23 (empty -> .)

    params                         shift and go to state 81
    params_var                     shift and go to state 82
    empty                          shift and go to state 83

state 64

    (52) ass_exp -> id equals expression .
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    semicolon       reduce using rule 52 (ass_exp -> id equals expression .)
    minus           shift and go to state 28
    plus            shift and go to state 29


state 65

    (27) val -> id .

    comma           reduce using rule 27 (val -> id .)
    rparent         reduce using rule 27 (val -> id .)


state 66

    (24) call -> id lparent arguments . rparent semicolon

    rparent         shift and go to state 84


state 67

    (25) call -> id lparent rparent . semicolon

    semicolon       shift and go to state 85


state 68

    (33) arguments -> val . comma arguments
    (34) arguments -> val .

    comma           shift and go to state 86
    rparent         reduce using rule 34 (arguments -> val .)


state 69

    (19) factor -> lparent expression rparent .

    multiply        reduce using rule 19 (factor -> lparent expression rparent .)
    divide          reduce using rule 19 (factor -> lparent expression rparent .)
    minus           reduce using rule 19 (factor -> lparent expression rparent .)
    plus            reduce using rule 19 (factor -> lparent expression rparent .)
    $end            reduce using rule 19 (factor -> lparent expression rparent .)
    semicolon       reduce using rule 19 (factor -> lparent expression rparent .)
    rparent         reduce using rule 19 (factor -> lparent expression rparent .)
    equals_equals   reduce using rule 19 (factor -> lparent expression rparent .)
    lt              reduce using rule 19 (factor -> lparent expression rparent .)
    gt              reduce using rule 19 (factor -> lparent expression rparent .)
    le              reduce using rule 19 (factor -> lparent expression rparent .)
    ge              reduce using rule 19 (factor -> lparent expression rparent .)
    not_equal       reduce using rule 19 (factor -> lparent expression rparent .)


state 70

    (35) comp_block -> lcparent block rcparent .

    return          reduce using rule 35 (comp_block -> lcparent block rcparent .)
    lcparent        reduce using rule 35 (comp_block -> lcparent block rcparent .)
    for             reduce using rule 35 (comp_block -> lcparent block rcparent .)
    if              reduce using rule 35 (comp_block -> lcparent block rcparent .)
    var             reduce using rule 35 (comp_block -> lcparent block rcparent .)
    let             reduce using rule 35 (comp_block -> lcparent block rcparent .)
    id              reduce using rule 35 (comp_block -> lcparent block rcparent .)
    func            reduce using rule 35 (comp_block -> lcparent block rcparent .)
    else            reduce using rule 35 (comp_block -> lcparent block rcparent .)
    lparent         reduce using rule 35 (comp_block -> lcparent block rcparent .)
    minus           reduce using rule 35 (comp_block -> lcparent block rcparent .)
    int             reduce using rule 35 (comp_block -> lcparent block rcparent .)
    $end            reduce using rule 35 (comp_block -> lcparent block rcparent .)


state 71

    (42) loop_block -> for lparent loop_var . condition semicolon step semicolon rparent
    (49) condition -> . expression relation_operator expression
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    condition                      shift and go to state 87
    expression                     shift and go to state 75
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 72

    (45) loop_var -> var_dekl .

    lparent         reduce using rule 45 (loop_var -> var_dekl .)
    minus           reduce using rule 45 (loop_var -> var_dekl .)
    int             reduce using rule 45 (loop_var -> var_dekl .)
    id              reduce using rule 45 (loop_var -> var_dekl .)


state 73

    (46) loop_var -> id .
    (9) var_dekl -> id . ddot dtype semicolon
    (10) var_dekl -> id . ddot dtype equals expression semicolon

    lparent         reduce using rule 46 (loop_var -> id .)
    minus           reduce using rule 46 (loop_var -> id .)
    int             reduce using rule 46 (loop_var -> id .)
    id              reduce using rule 46 (loop_var -> id .)
    ddot            shift and go to state 88


state 74

    (43) cond_block -> if lparent condition . rparent comp_block
    (44) cond_block -> if lparent condition . rparent comp_block else comp_block

    rparent         shift and go to state 89


state 75

    (49) condition -> expression . relation_operator expression
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term
    (53) relation_operator -> . equals_equals
    (54) relation_operator -> . lt
    (55) relation_operator -> . gt
    (56) relation_operator -> . le
    (57) relation_operator -> . ge
    (58) relation_operator -> . not_equal

    minus           shift and go to state 28
    plus            shift and go to state 29
    equals_equals   shift and go to state 91
    lt              shift and go to state 92
    gt              shift and go to state 93
    le              shift and go to state 94
    ge              shift and go to state 95
    not_equal       shift and go to state 96

    relation_operator              shift and go to state 90

state 76

    (50) ass_exp -> var id ddot dtype . equals expression
    (9) var_dekl -> id ddot dtype . semicolon
    (10) var_dekl -> id ddot dtype . equals expression semicolon

    equals          shift and go to state 97
    semicolon       shift and go to state 98


state 77

    (11) dtype -> int .

    equals          reduce using rule 11 (dtype -> int .)
    semicolon       reduce using rule 11 (dtype -> int .)
    comma           reduce using rule 11 (dtype -> int .)
    rparent         reduce using rule 11 (dtype -> int .)
    lcparent        reduce using rule 11 (dtype -> int .)


state 78

    (12) dtype -> bool .

    equals          reduce using rule 12 (dtype -> bool .)
    semicolon       reduce using rule 12 (dtype -> bool .)
    comma           reduce using rule 12 (dtype -> bool .)
    rparent         reduce using rule 12 (dtype -> bool .)
    lcparent        reduce using rule 12 (dtype -> bool .)


state 79

    (51) ass_exp -> let id ddot dtype . equals expression
    (9) var_dekl -> id ddot dtype . semicolon
    (10) var_dekl -> id ddot dtype . equals expression semicolon

    equals          shift and go to state 99
    semicolon       shift and go to state 98


state 80

    (31) params_var -> id . ddot dtype comma params_var
    (32) params_var -> id . ddot dtype

    ddot            shift and go to state 100


state 81

    (28) fun_dekl -> func id lparent params . rparent arrow dtype comp_block

    rparent         shift and go to state 101


state 82

    (29) params -> params_var .

    rparent         reduce using rule 29 (params -> params_var .)


state 83

    (30) params -> empty .

    rparent         reduce using rule 30 (params -> empty .)


state 84

    (24) call -> id lparent arguments rparent . semicolon

    semicolon       shift and go to state 102


state 85

    (25) call -> id lparent rparent semicolon .

    multiply        reduce using rule 25 (call -> id lparent rparent semicolon .)
    divide          reduce using rule 25 (call -> id lparent rparent semicolon .)
    minus           reduce using rule 25 (call -> id lparent rparent semicolon .)
    plus            reduce using rule 25 (call -> id lparent rparent semicolon .)
    $end            reduce using rule 25 (call -> id lparent rparent semicolon .)
    semicolon       reduce using rule 25 (call -> id lparent rparent semicolon .)
    rparent         reduce using rule 25 (call -> id lparent rparent semicolon .)
    equals_equals   reduce using rule 25 (call -> id lparent rparent semicolon .)
    lt              reduce using rule 25 (call -> id lparent rparent semicolon .)
    gt              reduce using rule 25 (call -> id lparent rparent semicolon .)
    le              reduce using rule 25 (call -> id lparent rparent semicolon .)
    ge              reduce using rule 25 (call -> id lparent rparent semicolon .)
    not_equal       reduce using rule 25 (call -> id lparent rparent semicolon .)


state 86

    (33) arguments -> val comma . arguments
    (33) arguments -> . val comma arguments
    (34) arguments -> . val
    (26) val -> . int
    (27) val -> . id

    int             shift and go to state 25
    id              shift and go to state 65

    val                            shift and go to state 68
    arguments                      shift and go to state 103

state 87

    (42) loop_block -> for lparent loop_var condition . semicolon step semicolon rparent

    semicolon       shift and go to state 104


state 88

    (9) var_dekl -> id ddot . dtype semicolon
    (10) var_dekl -> id ddot . dtype equals expression semicolon
    (11) dtype -> . int
    (12) dtype -> . bool

    int             shift and go to state 77
    bool            shift and go to state 78

    dtype                          shift and go to state 105

state 89

    (43) cond_block -> if lparent condition rparent . comp_block
    (44) cond_block -> if lparent condition rparent . comp_block else comp_block
    (35) comp_block -> . lcparent block rcparent

    lcparent        shift and go to state 20

    comp_block                     shift and go to state 106

state 90

    (49) condition -> expression relation_operator . expression
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 107
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 91

    (53) relation_operator -> equals_equals .

    lparent         reduce using rule 53 (relation_operator -> equals_equals .)
    minus           reduce using rule 53 (relation_operator -> equals_equals .)
    int             reduce using rule 53 (relation_operator -> equals_equals .)
    id              reduce using rule 53 (relation_operator -> equals_equals .)


state 92

    (54) relation_operator -> lt .

    lparent         reduce using rule 54 (relation_operator -> lt .)
    minus           reduce using rule 54 (relation_operator -> lt .)
    int             reduce using rule 54 (relation_operator -> lt .)
    id              reduce using rule 54 (relation_operator -> lt .)


state 93

    (55) relation_operator -> gt .

    lparent         reduce using rule 55 (relation_operator -> gt .)
    minus           reduce using rule 55 (relation_operator -> gt .)
    int             reduce using rule 55 (relation_operator -> gt .)
    id              reduce using rule 55 (relation_operator -> gt .)


state 94

    (56) relation_operator -> le .

    lparent         reduce using rule 56 (relation_operator -> le .)
    minus           reduce using rule 56 (relation_operator -> le .)
    int             reduce using rule 56 (relation_operator -> le .)
    id              reduce using rule 56 (relation_operator -> le .)


state 95

    (57) relation_operator -> ge .

    lparent         reduce using rule 57 (relation_operator -> ge .)
    minus           reduce using rule 57 (relation_operator -> ge .)
    int             reduce using rule 57 (relation_operator -> ge .)
    id              reduce using rule 57 (relation_operator -> ge .)


state 96

    (58) relation_operator -> not_equal .

    lparent         reduce using rule 58 (relation_operator -> not_equal .)
    minus           reduce using rule 58 (relation_operator -> not_equal .)
    int             reduce using rule 58 (relation_operator -> not_equal .)
    id              reduce using rule 58 (relation_operator -> not_equal .)


state 97

    (50) ass_exp -> var id ddot dtype equals . expression
    (10) var_dekl -> id ddot dtype equals . expression semicolon
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 108
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 98

    (9) var_dekl -> id ddot dtype semicolon .

    return          reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    var             reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    let             reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    lcparent        reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    for             reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    if              reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    id              reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    func            reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    lparent         reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    minus           reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    int             reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)
    $end            reduce using rule 9 (var_dekl -> id ddot dtype semicolon .)


state 99

    (51) ass_exp -> let id ddot dtype equals . expression
    (10) var_dekl -> id ddot dtype equals . expression semicolon
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 109
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 100

    (31) params_var -> id ddot . dtype comma params_var
    (32) params_var -> id ddot . dtype
    (11) dtype -> . int
    (12) dtype -> . bool

    int             shift and go to state 77
    bool            shift and go to state 78

    dtype                          shift and go to state 110

state 101

    (28) fun_dekl -> func id lparent params rparent . arrow dtype comp_block

    arrow           shift and go to state 111


state 102

    (24) call -> id lparent arguments rparent semicolon .

    multiply        reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    divide          reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    minus           reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    plus            reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    $end            reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    semicolon       reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    rparent         reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    equals_equals   reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    lt              reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    gt              reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    le              reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    ge              reduce using rule 24 (call -> id lparent arguments rparent semicolon .)
    not_equal       reduce using rule 24 (call -> id lparent arguments rparent semicolon .)


state 103

    (33) arguments -> val comma arguments .

    rparent         reduce using rule 33 (arguments -> val comma arguments .)


state 104

    (42) loop_block -> for lparent loop_var condition semicolon . step semicolon rparent
    (47) step -> . id add int
    (48) step -> . id sub int

    id              shift and go to state 113

    step                           shift and go to state 112

state 105

    (9) var_dekl -> id ddot dtype . semicolon
    (10) var_dekl -> id ddot dtype . equals expression semicolon

    semicolon       shift and go to state 98
    equals          shift and go to state 114


state 106

    (43) cond_block -> if lparent condition rparent comp_block .
    (44) cond_block -> if lparent condition rparent comp_block . else comp_block

    return          reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    lcparent        reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    for             reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    if              reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    var             reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    let             reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    id              reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    func            reduce using rule 43 (cond_block -> if lparent condition rparent comp_block .)
    else            shift and go to state 115


state 107

    (49) condition -> expression relation_operator expression .
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    rparent         reduce using rule 49 (condition -> expression relation_operator expression .)
    semicolon       reduce using rule 49 (condition -> expression relation_operator expression .)
    minus           shift and go to state 28
    plus            shift and go to state 29


state 108

    (50) ass_exp -> var id ddot dtype equals expression .
    (10) var_dekl -> id ddot dtype equals expression . semicolon
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

  ! shift/reduce conflict for semicolon resolved as shift
    semicolon       shift and go to state 116
    minus           shift and go to state 28
    plus            shift and go to state 29

  ! semicolon       [ reduce using rule 50 (ass_exp -> var id ddot dtype equals expression .) ]


state 109

    (51) ass_exp -> let id ddot dtype equals expression .
    (10) var_dekl -> id ddot dtype equals expression . semicolon
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

  ! shift/reduce conflict for semicolon resolved as shift
    semicolon       shift and go to state 116
    minus           shift and go to state 28
    plus            shift and go to state 29

  ! semicolon       [ reduce using rule 51 (ass_exp -> let id ddot dtype equals expression .) ]


state 110

    (31) params_var -> id ddot dtype . comma params_var
    (32) params_var -> id ddot dtype .

    comma           shift and go to state 117
    rparent         reduce using rule 32 (params_var -> id ddot dtype .)


state 111

    (28) fun_dekl -> func id lparent params rparent arrow . dtype comp_block
    (11) dtype -> . int
    (12) dtype -> . bool

    int             shift and go to state 77
    bool            shift and go to state 78

    dtype                          shift and go to state 118

state 112

    (42) loop_block -> for lparent loop_var condition semicolon step . semicolon rparent

    semicolon       shift and go to state 119


state 113

    (47) step -> id . add int
    (48) step -> id . sub int

    add             shift and go to state 120
    sub             shift and go to state 121


state 114

    (10) var_dekl -> id ddot dtype equals . expression semicolon
    (13) expression -> . expression minus term
    (14) expression -> . expression plus term
    (15) expression -> . term
    (16) term -> . term multiply factor
    (17) term -> . term divide factor
    (18) term -> . factor
    (19) factor -> . lparent expression rparent
    (20) factor -> . minus expression
    (21) factor -> . val
    (22) factor -> . call
    (26) val -> . int
    (27) val -> . id
    (24) call -> . id lparent arguments rparent semicolon
    (25) call -> . id lparent rparent semicolon

    lparent         shift and go to state 18
    minus           shift and go to state 9
    int             shift and go to state 25
    id              shift and go to state 35

    expression                     shift and go to state 122
    term                           shift and go to state 10
    factor                         shift and go to state 19
    val                            shift and go to state 23
    call                           shift and go to state 24

state 115

    (44) cond_block -> if lparent condition rparent comp_block else . comp_block
    (35) comp_block -> . lcparent block rcparent

    lcparent        shift and go to state 20

    comp_block                     shift and go to state 123

state 116

    (10) var_dekl -> id ddot dtype equals expression semicolon .

    return          reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    var             reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    let             reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    lcparent        reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    for             reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    if              reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    id              reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    func            reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    lparent         reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    minus           reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    int             reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)
    $end            reduce using rule 10 (var_dekl -> id ddot dtype equals expression semicolon .)


state 117

    (31) params_var -> id ddot dtype comma . params_var
    (31) params_var -> . id ddot dtype comma params_var
    (32) params_var -> . id ddot dtype

    id              shift and go to state 80

    params_var                     shift and go to state 124

state 118

    (28) fun_dekl -> func id lparent params rparent arrow dtype . comp_block
    (35) comp_block -> . lcparent block rcparent

    lcparent        shift and go to state 20

    comp_block                     shift and go to state 125

state 119

    (42) loop_block -> for lparent loop_var condition semicolon step semicolon . rparent

    rparent         shift and go to state 126


state 120

    (47) step -> id add . int

    int             shift and go to state 127


state 121

    (48) step -> id sub . int

    int             shift and go to state 128


state 122

    (10) var_dekl -> id ddot dtype equals expression . semicolon
    (13) expression -> expression . minus term
    (14) expression -> expression . plus term

    semicolon       shift and go to state 116
    minus           shift and go to state 28
    plus            shift and go to state 29


state 123

    (44) cond_block -> if lparent condition rparent comp_block else comp_block .

    return          reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    lcparent        reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    for             reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    if              reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    var             reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    let             reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    id              reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)
    func            reduce using rule 44 (cond_block -> if lparent condition rparent comp_block else comp_block .)


state 124

    (31) params_var -> id ddot dtype comma params_var .

    rparent         reduce using rule 31 (params_var -> id ddot dtype comma params_var .)


state 125

    (28) fun_dekl -> func id lparent params rparent arrow dtype comp_block .

    return          reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    var             reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    let             reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    lcparent        reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    for             reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    if              reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    id              reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    func            reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    lparent         reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    minus           reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    int             reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)
    $end            reduce using rule 28 (fun_dekl -> func id lparent params rparent arrow dtype comp_block .)


state 126

    (42) loop_block -> for lparent loop_var condition semicolon step semicolon rparent .

    return          reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    lcparent        reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    for             reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    if              reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    var             reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    let             reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    id              reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)
    func            reduce using rule 42 (loop_block -> for lparent loop_var condition semicolon step semicolon rparent .)


state 127

    (47) step -> id add int .

    semicolon       reduce using rule 47 (step -> id add int .)


state 128

    (48) step -> id sub int .

    semicolon       reduce using rule 48 (step -> id sub int .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for multiply in state 10 resolved as shift
WARNING: shift/reduce conflict for divide in state 10 resolved as shift
WARNING: shift/reduce conflict for semicolon in state 108 resolved as shift
WARNING: shift/reduce conflict for semicolon in state 109 resolved as shift
WARNING: reduce/reduce conflict in state 27 resolved using rule (dekl_list -> block)
WARNING: rejected rule (block -> dekl block) in state 27
