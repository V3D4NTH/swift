#  date: 8. 11. 2022
#  author: Daniel Schnurpfeil
#

from ete3 import Tree

from src.pl0_code_generator.pl0_const import Inst as t, Op as o, SymbolRecord, Pl0Const
from src.pl0_code_generator.pl0_utils import inst, op


# > The class Pl0 is a class that represents a PL/0 program
class Pl0(Pl0Const):

    def __init__(self, abstract_syntax_tree: Tree, symbol_table) -> None:
        """
        The function takes in an abstract syntax tree and initializes the code, ast, and stck attributes.

        :param abstract_syntax_tree: This is the abstract syntax tree that was generated by the parser
        :type abstract_syntax_tree: Tree
        """
        super().__init__()
        self.code = []
        self.ast = abstract_syntax_tree
        self.symbol_table = symbol_table
        self.generate_code(sub_tree=self.clear_tree(self.ast.iter_prepostorder()))
        # end of code
        self.generate_instruction(inst(t.ret), 0, 0)

    def generate_instruction(self, inst_name, param1, param2):
        """
        It appends a list of three elements to the list called code

        :param inst_name: The name of the instruction
        :param param1: the first parameter of the instruction
        :param param2: the value of the second parameter
        """
        self.code.append([inst_name, param1, param2])

    def print_code(self):
        """
        It prints the code of the program
        """
        for index, c in enumerate(self.code):
            print(index, "", c[0], c[1], c[2])

    def print_symbol_table(self):
        """
        It prints the symbol table
        """
        for i in self.symbol_table.values():
            if i.type == "func":
                print(i.__str__())

                if i.params is not None:
                    print("--------params--------")
                    for j in i.params:
                        print(i.params[j].__str__())

                if i.locals is not None:
                    print("--------locals--------")
                    for k in i.locals:
                        print(i.locals[k].__str__())
            else:
                print(i.__str__())

    def return_code(self) -> str:
        """
        This function returns a string of the code in the format of "index opcode operand1 operand2"
        :return: The return_code method returns a string of the code.
        """
        code_string = ""
        for index, c in enumerate(self.code):
            code_string += (str(index) + " " + str(c[0]) + " " + str(c[1]) + " " + str(c[2]) + "\n")
        return code_string

    def gen_const(self, const):
        """
        It generates a constant

        :param const: The constant to be generated
        """
        if type(const) == int:
            self.generate_instruction(inst(t.lit), 0, const)

    def gen_opr(self, const1, operator: o, const2):
        """
        It generates instructions for the operation of two constants

        :param const1: The first constant to be used in the operation
        :param operator: o = enum('+', '-', '*', '/', '<', '>', '=', '<=', '>=', '<>', 'and', 'or', 'not', 'neg')
        :type operator: o
        :param const2: The second constant to be used in the operation
        """
        if const1:
            self.gen_const(const1)
        if const2:
            self.gen_const(const2)
        self.generate_instruction(inst(t.opr), 0, str(operator))

    def clear_tree(self, tree_iter_generator):
        """
        It takes a generator that yields tree iterators, and clears the tree of all rows

        :param tree_iter_generator: A generator that returns a Gtk.TreeIter for each row in the tree
        """
        sub_tree = []
        for i in tree_iter_generator:
            if not i[0]:
                sub_tree.append(i[1])
        return sub_tree

    def generate_code(self, sub_tree=None, level=0):
        sub_tree = list(sub_tree)
        index = 0
        while index < len(sub_tree):
            # ################################################################################
            #  generates expression_term statements
            # ################################################################################
            if sub_tree[index].name in self.expressions:
                leaves = sub_tree[index].get_leaf_names()
                if sub_tree[index].name == "expression_term":
                    self.expressions[sub_tree[index].name](leaves[0])
                elif leaves[0] in self.symbol_table.keys() and leaves[1] in self.symbol_table.keys():
                    self.expressions[sub_tree[index].name]()
                    index += 2
                elif leaves[0] in self.symbol_table.keys():
                    self.gen_load_symbol(self.symbol_table[leaves[0]])
                    self.expressions[sub_tree[index].name](leaves[1])
                    index += 1
                elif leaves[1] in self.symbol_table.keys():
                    self.gen_load_symbol(self.symbol_table[leaves[1]])
                    self.expressions[sub_tree[index].name](leaves[0])
                    index += 1
                else:
                    self.expressions[sub_tree[index].name](leaves[0], leaves[1])
                    index += 2
            # ################################################################################
            #  generates variable declaration statements
            # ################################################################################
            elif sub_tree[index].name == "var_declaration_expression":
                self.generate_instruction(inst(t.int), 0, 4)
                sub_sub_tree = self.clear_tree(sub_tree[index].children[2].iter_prepostorder())
                # shifting index to skip duplicates
                # recursive call
                self.generate_code(sub_tree=sub_sub_tree, level=level + 1)
                self.store_var(self.symbol_table[sub_tree[index].children[0].name])
                index += len(sub_sub_tree)
            # ################################################################################
            #  generates variable modification statements
            # ################################################################################
            elif sub_tree[index].name in self.var_modifications:
                self.var_modifications[sub_tree[index].name](sub_tree[index].name)
            # ################################################################################
            elif sub_tree[index].name == "var_modification":
                symbol_name = sub_tree[index].children[0].name
                sub_sub_tree = self.clear_tree(sub_tree[index].children[2].iter_prepostorder())
                oper_and_equals = sub_tree[index].children[1]
                # shifting index to skip duplicates
                # recursive call
                self.generate_code(sub_tree=sub_sub_tree, level=level + 1)
                index += len(sub_sub_tree)
                if oper_and_equals.name != "=":
                    self.gen_load_symbol(self.symbol_table[symbol_name])
                # shifting index to skip duplicates
                # recursive call
                self.generate_code(sub_tree=oper_and_equals, level=level + 1)
                index += 1
                self.store_var(self.symbol_table[symbol_name])
            # ################################################################################
            #  generates if (else) statements
            # ################################################################################
            elif sub_tree[index].name == "if_stmt" or sub_tree[index].name == "if_else_stmt":
                condition = sub_tree[index].children[0]
                block1 = sub_tree[index].children[1]
                block2 = None
                if sub_tree[index].name == "if_else_stmt":
                    block2 = sub_tree[index].children[2]
                if condition.children[1].get_leaf_names()[0] in self.cond_expressions:
                    index += 2
                    sub_sub_tree = self.clear_tree(condition.children[0].iter_prepostorder())
                    # shifting index to skip duplicates
                    # recursive call
                    self.generate_code(sub_tree=sub_sub_tree, level=level + 1)
                    index += len(sub_sub_tree)
                    sub_sub_tree = self.clear_tree(condition.children[2].iter_prepostorder())
                    # shifting index to skip duplicates
                    # recursive call
                    self.generate_code(sub_tree=sub_sub_tree, level=level + 1)
                    index += len(sub_sub_tree)
                    self.cond_expressions[condition.children[1].get_leaf_names()[0]]()
                    # block 1
                    sub_sub_tree = self.clear_tree(block1.children[0].iter_prepostorder())
                    # shifting index to skip duplicates
                    # recursive call
                    x = id("x" + str(level))
                    self.generate_instruction(inst(t.jmc), 0, x)
                    self.generate_code(sub_tree=sub_sub_tree, level=level + 1)
                    index += len(sub_sub_tree)
                    if block2 is not None:
                        # block 2
                        sub_sub_tree = self.clear_tree(block2.children[0].iter_prepostorder())
                        # shifting index to skip duplicates
                        # recursive call
                        y = id("y" + str(level))
                        self.generate_instruction(inst(t.jmp), 0, y)
                        self.generate_code(sub_tree=sub_sub_tree, level=level + 1)
                        index += len(sub_sub_tree)
                        for i in self.code:
                            if i[2] == y:
                                i[2] = len(self.code)
                    for i in self.code:
                        if i[2] == x:
                            i[2] = len(self.code)
            # ################################################################################
            # ################################################################################

            index += 1

    def store_var(self, var: SymbolRecord):
        self.generate_instruction(inst(t.sto), var.level, var.address)

    def gen_load_symbol(self, symbol: SymbolRecord):
        self.generate_instruction(inst(t.lod), symbol.level, symbol.address)

    def gen_opr_add(self, const1=None, const2=None):
        self.gen_opr(const1, op(o.add), const2)

    def gen_opr_sub(self, const1=None, const2=None):
        self.gen_opr(const1, op(o.sub), const2)

    def gen_opr_mul(self, const1=None, const2=None):
        self.gen_opr(const1, op(o.mul), const2)

    def gen_opr_div(self, const1=None, const2=None):
        self.gen_opr(const1, op(o.div), const2)

    def gen_term(self, const1=None, const2=None):
        self.gen_const(const1)

    def gen_sub(self, operator):
        self.generate_instruction(inst(t.opr), 0, op(o.sub))

    def gen_add(self, operator):
        self.generate_instruction(inst(t.opr), 0, op(o.add))

    def gen_mulby(self, operator):
        self.generate_instruction(inst(t.opr), 0, op(o.mul))

    def gen_divby(self, operator):
        self.generate_instruction(inst(t.opr), 0, op(o.div))

    def gen_equals(self, operator):
        pass

    def gen_lesser(self):
        self.generate_instruction(inst(t.opr), 0, op(o.lt))

    def gen_not_equal(self):
        self.generate_instruction(inst(t.opr), 0, op(o.ne))

    def gen_lesser_equals(self):
        self.generate_instruction(inst(t.opr), 0, op(o.le))

    def gen_greater(self):
        self.generate_instruction(inst(t.opr), 0, op(o.gt))

    def gen_greater_equals(self):
        self.generate_instruction(inst(t.opr), 0, op(o.ge))

    def gen_dos_equals(self):
        self.generate_instruction(inst(t.opr), 0, op(o.eq))
