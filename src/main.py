#  date: 8. 11. 2022
#  authors: Daniel Schnurpfeil,  Jiri Trefil
#
import os
from copy import copy

import ply.lex
import ply.yacc as yy

import src.syntax_analyzer as syntax
import src.lex_analyzer as lexical
import src.pl0_code_generator as gen
from src.syntax_analyzer.utils import generate_table_of_symbols
from src.semantics_analyzer.analyzer import Analyzer


def generate_output_files(dst, generated_code):
    """
    It generates output files

    :param dst: syntax tree
    :param generated_code: a list of strings, each of which is a line of generated code
    """
    if "output" not in os.listdir("../"):
        os.mkdir("../output")
    with open("../output/full_tree.txt", mode="w") as tree:
        tree.writelines(dst.get_ascii(attributes=["name", "dist", "label", "complex"]))
    with open("../output/tree.txt", mode="w") as tree:
        tree.writelines(str(dst))
    with open("../output/symbol_table.txt", mode="w") as table:
        generated_code.print_symbol_table(table.writelines)


def visualize_dst(dst, show_tree_with_pyqt5):
    # # ###### Showing the tree. with pyqt5 ##################
    if show_tree_with_pyqt5:
        from ete3 import TreeStyle
        tree_style = TreeStyle()
        tree_style.show_leaf_name = True
        tree_style.mode = "c"
        tree_style.arc_start = -180  # 0 degrees = 3 o'clock
        dst.show(
            tree_style=tree_style
        )


def save_generated_code(generated_code, formatted_input_code):
    """
    It saves the generated code to a file

    :param generated_code: The code that was generated by the model
    :param formatted_input_code: The input code, formatted with the correct indentation
    """
    if generated_code.return_code() != "":
        # Writing the generated code to a file.
        with open("../output/generated_code.txt", mode="w") as txt:
            txt.writelines("----------input code----------------\n")
            txt.writelines(formatted_input_code)
            txt.writelines("\n")
            txt.writelines("----------generated code------------\n")
            txt.writelines(generated_code.return_code())
            txt.writelines("------------------------------------")


def main(input_file_name: str, show_tree_with_pyqt5=False):
    """
    > This function takes a file name as input, and returns a list of lists of strings

    :param input_file_name: The name of the file to be parsed
    :type input_file_name: str
    :param show_tree_with_pyqt5: If True, the tree will be displayed using PyQt5, defaults to False (optional)
    """

    with open(input_file_name) as f:
        code = f.read()
    formatted_input_code = copy(code)
    # Parsing the code_input.
    lexer = \
    ply.lex.lex(module=lexical)
    y = yy.yacc(module=syntax, debug=True)
    dst = y.parse(formatted_input_code)

    # Generating a table of symbols.
    table_of_symbols = {}
    generate_table_of_symbols(table_of_symbols, symbols=dst.get_leaves())
    '''
    #[JT] ZATIM NECHAVAM ZAKOMENTOVANO - JE TO HODNE SYROVE
    semantics_analyzer = Analyzer(dst, table_of_symbols)
    if not semantics_analyzer.Analyze():
        return
    '''

    generated_code = gen.Pl0(dst, table_of_symbols)

    # Generating the output files.
    generate_output_files(dst, generated_code)

    # Showing the tree.
    visualize_dst(dst, show_tree_with_pyqt5)

    # Generating the instructions for the PL/0 compiler.
    generated_code.generate_instructions()

    # Saving the generated code to a file.
    save_generated_code(generated_code, formatted_input_code)

    return generated_code.return_code()


if __name__ == '__main__':
    # main("../sample_input/not_tested/func.swift")
    main("../sample_input/program.swift", show_tree_with_pyqt5=True)
    # main("../sample_input/not_tested/for_in_func.swift")
